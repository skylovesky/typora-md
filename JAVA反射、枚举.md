#### 反射简介

​		JAVA在运行时才得知需要并使用编译时完全未知的类，创建这个未知类，改变其属性，调用其方法。这个时候就需要用到**反射技术**。

​		反射技术允许程序在**运行时**，借助Reflection API取得任何类的内部信息，并直接操纵器属性和方法。

> - Java反射机制是在运行状态中
> - 对于**任意一个类**，都能知道这个类的所以**属性和方法**；
> - 对于**任何一个对象**，都能够调用它的任何一个**方法和属性**；
> - 这样**动态获取**新的以及**动态调用**对象方法的功能就叫做**反射**。

#### Class类

1. Class可以说是反射能够实现的基础
2. class关键字是在声明java类时使用的；而Class 是java JDK提供的一个类,完整路径为 java.lang.Class
3. **对于每一种类，Java虚拟机都会初始化出一个Class类型的实例，每当我们编写并且编译一个新创建的类就会产生一个对应Class对象，并且这个Class对象会被保存在同名.class文件里。**
4. 当我们new一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。
    **构造器是私有的，只有JVM才可以调用这个构造函数创建Class的对象** 
5. 每个class（注意class是小写，代表普通类）类，无论创建多少个实例对象，在JVM中都对应同一个Class对象。
6. Class是反射能够实现的基础的另一个原因是：Java反射包[`java.lang.reflect`](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html)中的所有类都没有public构造方法，要想获得这些类实例，只能通过Class类获取。所以说如果想使用反射，必须得获得Class对象。



#### 类的加载

##### 概述

 		类的加载指的是

​		将类的.class文件中的二进制数据读入到内存中，

​		将其放在运行时数据区的**方法区**内，然后在**堆区**创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。

​		**类的加载的最终产品是位于堆区中的Class对象**，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。

​		 **类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它**，

​		**如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）**如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误 



##### 类初始化时机

1. 遇到new、getstatic、putstatic或invokestatic这4条**字节码指令**时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见：
   - 使用new关键字实例化对象的时候
   - 读取或设置一个类的静态字段的时候(getstatic 或 putstatic )，被final修饰、已在编译期把结果放入常量池的静态字段除外
   - 调用一个类的静态方法的时候（invokestatic）
2. 当调用Java API中的某些反射方法是，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（ mian() ）,虚拟机会先初始化这个类。



##### 类的加载

加载是类加载过程的一个阶段，这两个概念一定不要混淆。在加载阶段, 虚拟机需要完成以下三件事情 ：

1.  通过一个类的全限定名来获取定义此类的二进制字节流。 
2.  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 
3.  将类的class文件读入内存，并为之创建一个java.lang.Class对象，也就是说当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象, 作为方法区这个类的各种数据的访问入口。 

 通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源： 

-  从本地文件系统加载class文件； 
-  从一个ZIP、 JAR、 CAB或者其他某种归档文件中提取Java class文件，JDBC编程时使用到的数据库驱动就是放在JAR文件中，JVM可以直接从JAR包中加载class文件； 
-  通过网络加载class文件，这种场景最典型的应用就是 Applet； 
-  把一个java源文件动态编译、并执行加载 
-  运行时计算生成, 这种场景使用得最多的就是动态代理接术, 在 java.lang.reflect.Proxy中 , 就是用了 ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。 



##### 类的连接

 当类被加载后，系统为之生成一个对应的Class对象，接着会进入连接阶段，连接阶段将会负责把类的二进制文件合并到JRE中。类连接分为如下三个阶段： 

- 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致；
- 准备：准备阶段则负责为类的静态属性分配内存，并设置默认初始值；
- 解析：将类的二进制数据中的符号引用替换成直接引用（符号引用是用一组符号描述所引用的目标；直接引用是指向目标的指针）



##### 准备

##### 解析

##### 类的初始化

 初始化阶段是类加载过程的最后一步 , 前面的几个阶段, 除了在加载阶段用户应用程序可以通过自定 义类加载器參与之外, 其余动作完全由虚拟机主导和控制。到了初始化阶段, 才真正开始执行类中定义的 Java程序代码。 



#### 枚举

```java
public abstract class Enum<E extends Enum<E>>  implements Comparable<E>, Serializable 
```

Java1.5新增的类型，用来定义一组取值范围固定的变量。

1. Enum 类是枚举的一个封装类，是所有枚举类型的超累，是一个没有抽象方法的抽象类，但是有各种实现方法

   ​	比较枚举元素的顺序

   - ```java
     public final int compareTo(E o) {    
         Enum<?> other = (Enum<?>)o;
         Enum<E> self = this;
         if (self.getClass() != other.getClass() && 
             self.getDeclaringClass() != other.getDeclaringClass())
             throw new ClassCastException();   
         return self.ordinal - other.ordinal;
     }
     ```

   - ....

2. 通过关键字enum定义枚举类型；

   

   ##### 定义枚举类

   ```java
   /**
   枚举类的构造方法是私有的
   */
   public enmu TypeEnmu{
   	MYSQL,DB2,ORACLE;
       //枚举对象要定义在枚举类的第一行
       //每一个枚举值都是该枚举的一个实例对象
       //在枚举类中所有的枚举对象以大写的形式存在
       //枚举对象之间用 ',' 隔开
   }
   ```

   